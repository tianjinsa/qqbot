# 防推销插件修复说明

## 本次修复的主要问题

### 1. 🔧 消息归属错误问题
**问题**: 在多用户频繁交叉发送消息时，合并转发会错误地将其他用户的消息当成被禁言用户的消息进行转发。

**根因**: 消息池中没有足够的归属验证，在并发情况下可能出现消息混淆。

**解决方案**:
- 在消息记录中添加`group_id`和`user_id`字段进行双重验证
- 在`_get_user_messages_in_group`函数中验证消息归属
- 在转发函数中进行多重验证，过滤掉归属错误的消息
- 添加详细的错误日志记录

### 2. 🔒 并发安全问题
**问题**: 消息池在并发访问时可能出现竞态条件。

**解决方案**:
- 添加`message_pool_lock`异步锁保护消息池的读写操作
- 确保所有参数类型一致性（统一转换为字符串）

### 3. ⚙️ AI调用并发控制
**问题**: 缺少AI调用的并发限制，可能导致服务器过载。

**解决方案**:
- 添加`ai_semaphore`信号量控制并发AI调用
- 新增配置项`MAX_CONCURRENT_AI_CALLS`（默认3）
- 在所有AI模型调用处添加并发控制

### 4. ⏱️ 批量处理优化
**问题**: 批量处理缓冲时间硬编码，无法灵活调整。

**解决方案**:
- 添加配置项`BATCH_WAIT_TIME`（默认5.0秒）
- 改进批量处理逻辑的可配置性

## 新增配置项

| 配置项 | 默认值 | 说明 |
|--------|--------|------|
| `BATCH_WAIT_TIME` | `5.0` | 批量处理等待时间（秒） |
| `MAX_CONCURRENT_AI_CALLS` | `3` | AI调用并发上限 |

## 代码改进点

### 1. 消息存储改进
```python
# 添加归属验证字段
message_record = {
    "timestamp": timestamp,
    "message_id": str(message_id) if message_id else "",
    "recalled": False,
    "original_messages": original_messages or [],
    "group_id": group_id,  # 新增：群聊ID验证
    "user_id": user_id     # 新增：用户ID验证
}
```

### 2. 消息获取验证
```python
# 验证消息确实属于指定的群聊和用户
if (msg_record.get("group_id") == group_id and 
    msg_record.get("user_id") == user_id):
    user_messages.append(msg_record.copy())
else:
    logger.warning(f"发现错误的消息归属...")
```

### 3. 转发验证
```python
# 转发前验证所有消息归属
valid_messages = []
for msg_record in user_messages:
    if (msg_record.get("group_id") == group_id and 
        msg_record.get("user_id") == user_id):
        valid_messages.append(msg_record)
    else:
        logger.error(f"转发时发现消息归属错误...")
```

### 4. 并发控制
```python
# AI调用并发控制
async with self.ai_semaphore:
    # AI模型调用逻辑
    
# 消息池访问保护
async with self.message_pool_lock:
    # 消息池操作
```

## 使用建议

1. **监控日志**: 关注"消息归属错误"相关的错误日志，如果频繁出现需要进一步调查
2. **性能调优**: 根据服务器性能调整`MAX_CONCURRENT_AI_CALLS`
3. **批量处理**: 根据群聊活跃度调整`BATCH_WAIT_TIME`
4. **定期检查**: 使用`/spam_debug`命令定期检查插件状态

## 测试建议

1. 在多用户频繁发言的群聊中测试转发功能
2. 检查管理员群聊中收到的转发消息是否只包含被禁言用户的消息
3. 观察日志中是否有消息归属错误的警告
4. 测试AI调用的并发限制是否生效
